- --
# assignment
In Elixir we uses the match operator. It behaves more like an **assertion**. What it actually does it check if both sides between the match operator match. What is the match operator... its actual the thing we call assignment???? in other languages the `=` thing.

So basically to my understanding with the example of `a = 1`. It will check if both sides evaluate to **true**. If so then a is 1.

# lists
They are created using square brackets. ~> `[]`

```elixir
> a = [1,2,3]
```

# pattern matching
- --
So ... its looks like this. 
```elixir
> a = [1,2,3]
> [a,b,c] = a
```

This won't return an error because. the Left and side is being **pattern matched** to the right hand side. Now there corresponding values

# ignore values with _

the under score is basically a variable witch will immediately discard its self. And will allow you to pas in other values in a pattern match. 

```elixir
> [1,_,_] = [1,2,3]
[1,2,3]
> [1,_,_] = [1,"cat","dog"]
[1,"cat","dog"]
```

**Note!:** Once a variable has been bound to a value in the matching process, it keeps
that value for the remainder of the match.

# the pin operator
In Elixir unlike Haskell you can rebind variables. But when using the pin operator `^ (a carot)`. it won't let you do this.

```elixir
x = 10
^x = 10   # ✅ matches
^x = 20   # ❌ MatchError
```

