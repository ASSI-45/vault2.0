-- -
```elixir
iex> sum = fn (a, b) -> a + b end
#Function<12.17052888 in :erl_eval.expr/5>
iex> sum.(1, 2)
3
```

The first line of code creates a function that takes two parameters (named a
and b). The implementation of the function follows the -> arrow (in our case
it simply adds the two parameters), and the whole thing is terminated with
the keyword end. We store the function in the variable sum.

On the second line of code, we invoke the function using the syntax sum.(1,2).
The dot indicates the function call, and the arguments are passed between
parentheses. (You’ll have noticed we don’t use a dot for named function
calls—this is a difference between named and anonymous functions.)

**_Note!:_** If your function takes no arguments, you still need the parentheses to call it.
**_Note!:_** You can, however, omit the parentheses in a function definition.

As noted in the other last chapters _elixir_ uses pattern matching in its "assignment" and not actual assignment.

You can have multiple function definitions in ones function.
```elixir
handle_open = fn
{:ok, file} -> "First line: #{IO.read(file, :line)}"
{_,
error} -> "Error: #{:file.format_error(error)}"
end
```

## Functions Remember Their Original Environment
-- -
Let’s take this idea of nesting functions a little further.
```elixir
iex> greeter = fn name -> (fn -> "Hello #{name}" end) end
#Function<12.17052888 in :erl_eval.expr/5>
iex> dave_greeter = greeter.("Dave")
#Function<12.17052888 in :erl_eval.expr/5>
iex> dave_greeter.()
"Hello Dave"
```