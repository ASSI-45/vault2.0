-- -
This a part 2 to the [[4. elixir basics]]. Here we will cover the next.

+ [[#Dates and Times]]
+ [[#Names, Source Files, Conventions, Operators, and So On]]
+ 

## Dates and Times
-- -
The Calendar module represents the rules used to manipulate dates. The only
current implementation is Calendar.ISO, the _ISO-8601_ representation of the
Gregorian **calendar.2**.

```elixir
iex> d1 = Date.new(2018, 12, 25)
{:ok, ~D[2018-12-25]}

iex> {:ok, d1} = Date.new(2018, 12, 25)
{:ok, ~D[2018-12-25]}

iex> d2 = ~D[2018-12-25]
~D[2018-12-25]

iex> d1 == d2
true
iex> Date.day_of_week(d1)
2

iex> Date.add(d1, 7)
~D[2019-01-01]

iex> inspect d1, structs: false
"%{__struct__: Date, calendar: Calendar.ISO, day: 25, month: 12, year: 2018}"
```

Elixir can also represent a range of dates.

## Names, Source Files, Conventions, Operators, and So On
-- -
Here are some examples of valid variables:
`name`
`josé`
`_age`
`まつもと`
`_42`
`адрес!`

And some examples of invalid variables:
`name•`
`a±2`
`42`

**_Note!:_** Module, record, protocol, and behavior names start with an uppercase letter
and are BumpyCase. All other identifiers start with a lowercase letter or an
underscore, and by convention use underscores between words. If the first
character is an underscore, Elixir doesn’t report a warning if the variable is
unused in a pattern match or function parameter list. By convention, source files use two-character indentation for nesting—and
they use spaces, not tabs, to achieve this.
Comments start with a hash sign (#) and run to the end of the line.

### Truth
Elixir has three special values related to Boolean operations: true, false, and
nil. nil is treated as false in Boolean contexts.

**_Note!:_** True is the same as the atom :true.

**_Important!:_** In most contexts, any value other than false or nil is treated as true. We
sometimes refer to this as _truthy_ as opposed to true.

### Operators
##### Logic
```elixir
a === b # strict equality (so 1 === 1.0 is false)
a !== b # strict inequality (so 1 !== 1.0 is true)
a == b # value equality (so 1 == 1.0 is true)
a != b # value inequality (so 1 != 1.0 is false)
a > b # normal comparison
a >= b # :
a < b # :
a <= b # :
```

The ordering comparisons in Elixir are less strict than in many languages,
as you can compare values of different types. If the types are the same or are
compatible (for example, 3 > 2 or 3.0 < 5), the comparison uses natural ordering.
Otherwise comparison is based on type according to this rule:

**_number < atom < reference < function < port < pid < tuple < map < list < binary_**

##### Boolean operators
These operators **expect** _true_ or _false_ as there first argument.
```elixir
a or b # true if a is true; otherwise b
a and b # false if a is false; otherwise b
not a # false if a is true; true otherwise
```

##### Relaxed operators
These operators take arguments of any type. Any value apart from nil or
false is interpreted as true.

```
a || b # a if a is truthy; otherwise b
a && b # b if a is truthy; otherwise a
!a # false if a is truthy; otherwise true
```
