- --
This chapter is an abrupt chapter on the basic types in elixir.

-  [[#Values types]]:
	+ [[#Arbitrary-sized integers]]
	+ [[#Floating-point numbers]]
	+ [[#Atoms]]
	+ [[#Ranges]]
	+ [[#Regular expressions]]
- [[#System types]]:
	+ [[#PIDs and ports]]
	+ [[#References]]
- [[#Collection types]]:
	+ [[#Tuples]]
	+ [[#Lists]]
	+ [[#Maps]]
	+ [[#Binaries]]

**_Note!:_** Functions are types to you can read about it in [[5. Anonymous functions]].

You might be surprised that this list doesn’t include things such as strings
and structures. Elixir has them, but they are built using the basic types from
this list. However, they are important. Strings have their own chapter, and we have a couple of chapters on lists and maps (and other dictionary-like
types). The maps chapter also describes the Elixir structure facilities.

Finally, there’s some debate about whether regular expressions and ranges
are value types. Technically they aren’t—under the hood they are just structures. But right now it’s convenient to treat them as distinct types.

# Values types
-- -
Values types represent a lot of types. Such as numbers, names, ranges and regular expressions

## Arbitrary-sized integers
Integer literals can be written as decimal (1234), hexadecimal (0xcafe), octal
(0o765), and binary (0b1010).

Decimal numbers may contain underscores—these are often used to separate
groups of three digits when writing large numbers, so one million could be
written 1_000_000 (or perhaps 100_0000 in China and Japan).

There is no fixed limit on the size of integers—their internal representation
grows to fit their magnitude.

```elixir
factorial(10000) # => 28462596809170545189...and so on for 35640 more digits...
```


## Floating-point numbers
Floating-point numbers are written using a decimal point. There must be at
least one digit before and after the decimal point. An optional trailing exponent
may be given. These are all valid floating-point literals:
1.0
0.2456
0.314159e1 314159.0e-5

**_Note!:** Floats are IEEE 754 double precision, giving them about 16 digits of accuracy
and a maximum exponent of around 10308.

## Atoms
Atoms are constants that represent something’s name. We write them using
a leading colon (:), which can be followed by an atom word or an Elixir opera-
tor. An atom word is a sequence of UTF-8 letters (including combining marks),
digits, underscores, and at signs (@). It may end with an exclamation point
or a question mark. You can also create atoms containing arbitrary characters by enclosing the characters following the colon in double quotes. These are
all atoms:

```elixir
:fred :is_binary? :var@2 :<> :=== :"func/3"
:"long john silver" :эликсир
:mötley_crüe
```

**_Note!_**: An atom’s name is its value. Two atoms with the same name will always
compare as being equal, even if they were created by different applications
on two computers separated by an ocean.

In the book atoms are used to tag values a lot.

## Ranges
Ranges are represented as start..end, where start and end are integers.

## Regular expressions
Elixir has regular-expression literals, written as ~r{regexp} or ~r{regexp}opts.
Here I show the delimiters for regular-expression literals as { and }, but they
are considerably more flexible. You can choose any nonalphanumeric characters as delimiters, as described in the discussion of sigils on page 118. Some
people use ~r/…/ for nostalgic reasons, but this is less convenient than the
bracketed forms, as any forward slashes inside the pattern must be escaped.
Elixir regular expression support is provided by PCRE,1 which basically pro-
vides a Perl 5–compatible syntax for patterns.
You can specify one or more single-character options following a regexp literal.
These modify the literal’s match behavior or add functionality.

![[2025-12-23_08-27-58_2xDec.png]]

You manipulate regular expressions with the Regex module.

```elixir
iex> Regex.run ~r{[aeiou]}, "caterpillar"
["a"]
iex> Regex.scan ~r{[aeiou]}, "caterpillar"
[["a"], ["e"], ["i"], ["a"]]
iex> Regex.split ~r{[aeiou]}, "caterpillar"
["c", "t", "rp", "ll", "r"]
iex> Regex.replace ~r{[aeiou]}, "caterpillar", "*"
"c*t*rp*ll*r"
```

# System types
- --
These are types from the underling Erlang virtual machine.

## PIDs and ports
A **PID** is a local or external process, and a **port** is a reference to a resource (typically external to the application) that you’ll be reading or writing.

## References
The function make_ref creates a globally unique reference; no other reference
will be equal to it.

**_Note!:_** There are no **refrences** used in the book.

# Collection types
-- -
The types above are common for many of programming languages. But the next one's are a bit more exotic. So they are explained more detailed in the book.

## Tuples
A tuple is an ordered collection of values. As with all Elixir data structures,
once created a tuple cannot be modified.

```elixir
{ 1, 2 } { :ok, 42, "next"} { :error, :enoent }
```

**_Note!:_** `enoent` -> file does not exist, in Unix terms.
**_Note!:_** If your tuple has more than for elements you might wan't to use a **map** or a **struct**.

Feel free to use tuples in pattern matching.

```elixir
iex> {status, count, action} = {:ok, 42, "next"}
{:ok, 42, "next"}
iex> status
:ok
iex> count
42
iex> action
"next"
```

When error handling. It is common to write matches that assume _success_:

```elixir
iex> { :ok, file } = File.open("mix.exs")
{:ok, #PID<0.39.0>}
iex> { :ok, file } = File.open("non-existent-file")
** (MatchError) no match of right hand side value: {:error, :enoent}
```

## Lists
They look like this `[1,2,3]`. But there not arrays. Arrays don't exist in Elixir because there computationally to heavy. If you want something like an array you'll have to use an Tuple.

**_Definition:_** A list may either be empty or consist of a head and a tail. The head
contains a value and the tail is itself a list.

Because of their implementation, lists are easy to traverse linearly, but they
are expensive to access in random order. (To get to the nth element, you have
to scan through n–1 previous elements.) It is always cheap to get the head of
a list and to extract the tail of a list.

Lists have one other performance characteristic. Remember that we said all
Elixir data structures are immutable? That means once a list has been made,
it will never be changed. So, if we want to remove the head from a list, leaving
just the tail, we never have to copy the list. Instead we can return a pointer
to the tail. This is the basis of all the list-traversal tricks we’ll cover in Chapter
7, Lists and Recursion, on page 71.

these are some operators specific to lists.

```elixir
iex> [ 1, 2, 3 ] ++ [ 4, 5, 6 ] # concatenation
[1, 2, 3, 4, 5, 6]
iex> [1, 2, 3, 4] -- [2, 4] # difference
[1, 3]
iex> 1 in [1,2,3,4] # membership
true
iex> "wombat" in [1, 2, 3, 4]
false
```

### keyword lists
Because we often need simple lists of key/value pairs, Elixir gives us a
shortcut. If we write.

```elixir
[ name: "Dave", city: "Dallas", likes: "Programming" ]
```

We get an list of tuples.

```elixir
[ {:name, "Dave"}, {:city, "Dallas"}, {:likes, "Programming"} ]
```

Elixir allows us to leave off the square brackets if a keyword list is the last
argument in a function call. Thus the following code can also be written as.

```elixir
DB.save record, [ {:use_transaction, true}, {:logging, "HIGH"} ]
# same as
DB.save record, use_transaction: true, logging: "HIGH"
```

We can also leave off the brackets if a keyword list appears as the last item
in any context where a list of values is expected.

```elixir
iex> [1, fred: 1, dave: 2]
[1, {:fred, 1}, {:dave, 2}]
iex> {1, fred: 1, dave: 2}
{1, [fred: 1, dave: 2]}
```

## Maps
-- -
A map is data structure that consist of key and value pairs. The structure looks like this.

```elixir
%{ key => value, key => value } # structure

iex> states = %{ "AL" => "Alabama", "WI" => "Wisconsin" }
%{"AL" => "Alabama", "WI" => "Wisconsin"}

iex> responses = %{ { :error, :enoent } => :fatal, { :error, :busy } => :retry }
%{{:error, :busy} => :retry, {:error, :enoent} => :fatal}

iex> colors = %{ :red => 0xff0000, :green => 0x00ff00, :blue => 0x0000ff }
%{blue: 255, green: 65280, red: 16711680}
```

Why do we have both maps and keyword lists? Maps allow only one entry for
a particular key, whereas keyword lists allow the key to be repeated. Maps
are efficient (particularly as they grow), and they can be used in Elixir’s pattern
matching, which is discuss in later chapters.

In general, use keyword lists for things such as command-line parameters and
passing around options, and use maps when you want an associative array.

### Accessing Maps
You extract values from a map using the key. The square-bracket syntax
works with all maps.

```elixir
iex> states = %{ "AL" => "Alabama", "WI" => "Wisconsin" }
%{"AL" => "Alabama", "WI" => "Wisconsin"}

iex> states["AL"]
"Alabama"

iex> states["TX"]
nil

iex> response_types = %{ { :error, :enoent } => :fatal,
...>
{ :error, :busy } => :retry }
%{{:error, :busy} => :retry, {:error, :enoent} => :fatal}

iex> response_types[{:error,:busy}]
:retry
```

If the keys are atoms, you can also use a dot notation.

```elixir
iex> colors = %{ red: 0xff0000, green: 0x00ff00, blue: 0x0000ff }
%{blue: 255, green: 65280, red: 16711680}

iex> colors[:red]
16711680

iex> colors.green
65280
```

**_Note!:_** You’ll get a KeyError if there’s no matching key when you use the dot notation.

## Binaries
-- -
Pretty arcane, but shure here we go.

```elixir
iex> bin = << 1, 2 >>
<<1, 2>>

iex> byte_size bin
2
```

```elixir
iex> bin = <<3 :: size(2), 5 :: size(4), 1 :: size(2)>>
<<213>>

iex> :io.format("~-8.2b~n", :binary.bin_to_list(bin))
11010101
:ok

iex> byte_size bin
1
```

--- 
The next part is [[4. elixir basics part 2]].